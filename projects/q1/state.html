<!DOCTYPE html>
<html lang="en">
   <head>
      <title>joewing.net</title>
      <link rel="stylesheet" type="text/css" href="/style.css"/>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
      <script src="/include.js"></script>
   </head>
   <body>
      <div w3-include-html="/nav.html"></div>
      <div id="content">

<h1>Q1 State Machine</h1>

<h2>Contents</h2>
<ul>
   <li><a href="#gen">Clock Generation</a></li>
   <li><a href="#phases">Clock Phases</a></li>
   <li><a href="#phaselogic">Phase Transistion Logic</a></li>
   <li><a href="#states">States</a></li>
   <li><a href="#statelogic">State Transistion Logic</a></li>
   <li><a href="#class">Class Decoder</a></li>
   <li><a href="#func">Function Decoder</a></li>
   <li><a href="#control">Control Lines</a></li>
</ul>

<h2 id="gen">Clock Generation</h2>
<p>
The clock is generated by a 2-transistor astable multivibrator tied to
a Schmitt trigger.
Here's the <a href="images/clock-generator.png">schematic</a>.
<br/>
The output frequency is stable from about 30 Hz to 300 Hz, which could
easily be increased by using smaller capacitors.<br/>
12 transistors are needed.
</p>

<h2 id="phases">Clock Phases</h2>
<p>
Each clock from the clock generator switches the clock phase on the
positive edge. Clock phases are used so that transparent latches can
be used for registers to reduce transistor count at the price of speed.
The state clock (SC) and write clock (WC) are generated from two positive
edge-triggered flip-flops with input from combinatorial logic.<br/>
The initial state is 00.<br/>
Each flip-flop requires 19 transistors (5 NAND2 gates and 1 NAND3 gate),
thus 38 transistors are required to keep phase state.<br/>
Asynchronous reset is accomplished by pulling the inverting output to
ground via an open-collector NOT gate for each flip-flop. Therefore,
the total transistor count is 42.
</p>
<table class="listing">
   <tr class="head">
      <th>Encoding</th><th>State Clock</th><th>Write Strobe</th>
      <th>Next Phase</th>
   </tr>
   <tr class="listing">
      <td>00</td><td>0</td><td>0</td><td>11</td>
   </tr>
   <tr class="listing">
      <td>11</td><td>1</td><td>1</td><td>10</td>
   </tr>
   <tr class="listing">
      <td>10</td><td>1</td><td>0</td><td>00</td>
   </tr>
</table>
<p/>

<h2 id="phaselogic">Phase Transistion Logic</h2>
<p>
This is the logic used to compute the next clock phase.<br/>
Note that both inverted and non-inverted outputs are available as outputs,
but the input must be non-inverted.<br/>
7 transistors are needed for this logic.
</p>
<table class="listing">
   <tr class="head">
      <th>Signal</th>
      <th>Logic</th>
      <th>Simplified Logic</th>
      <th>Gate Count</th>
      <th>Transistor Count</th>
   </tr>
   <tr class="listing">
      <td>P[1]</td>
      <td>~P[1] | P[0]</td>
      <td>~(P[1] &amp; ~P[0])</td>
      <td class="nobr">1 NAND2</td>
      <td>3</td>
   </tr>
   <tr class="listing">
      <td>P[0]</td>
      <td>~P[1] &amp; ~P[0]</td>
      <td>~P[1] &amp; ~P[0]</td>
      <td class="nobr">1 AND2</td>
      <td>4</td>
   </tr>
</table>
<p/>

<h2 id="states">States</h2>
<p>
Eight positive edge-triggered flip-flops clocked from the state clock are
used to keep the state. The next state is computed from combinatorial
logic.<br/>
The initial state is 1000 0000.<br/>
Each flip-flop requires 19 transistors plus 2 for reset. Thus 168
transistors are needed here.
</p>
<table class="listing">
   <tr class="head">
      <th>Encoding</th><th>Name</th><th>Description</th><th>Next State</th>
   </tr>
   <tr class="listing">
      <td>1000 0000</td><td>sF1</td>
      <td>Fetch the opcode.</td>
      <td>0100 0000</td>
   </tr>
   <tr class="listing">
      <td>0100 0000</td><td>sP1</td>
      <td>Increment P.</td>
      <td class="nobr">
         If C0 or C1: 0010 0000<br/>
         Otherwise: 0000 0010
      </td>
   </tr>
   <tr class="listing">
      <td>0010 0000</td><td>sF2</td>
      <td>Fetch the first byte of the operand.</td>
      <td>0001 0000</td>
   </tr>
   <tr class="listing">
      <td>0001 0000</td><td>sP2</td>
      <td>Increment P.</td>
      <td>0000 1000</td>
   </tr>
   <tr class="listing">
      <td>0000 1000</td><td>sF3</td>
      <td>Fetch the second byte of the operand.</td>
      <td>0000 0100</td>
   </tr>
   <tr class="listing">
      <td>0000 0100</td><td>sP3</td>
      <td>Increment P. If this is a call instruction, X is written here.</td>
      <td>0000 0010</td>
   </tr>
   <tr class="listing">
      <td>0000 0010</td><td>EX</td>
      <td>Execute.</td>
      <td>1000 0000</td>
   </tr>
   <tr class="listing">
      <td>0000 0001</td><td>HT</td>
      <td>Halt.</td>
      <td>0000 0001</td>
   </tr>
</table>
<p/>

<h2 id="statelogic">State Transistion Logic</h2>
<p>
Both inverting and non-inverting outputs are available, but the input
must be non-inverting.<br/>
31 transistors are needed here.
</p>
<table class="listing">
   <tr class="head">
      <th>Signal</th>
      <th>Logic</th>
      <th>Simplified Logic</th>
      <th>Gate Count</th>
      <th>Transistor Count</th>
   </tr>
   <tr class="listing">
      <td>S[7]</td>
      <td>S[1] &amp; ~C3 &amp; F8</td>
      <td>S[1] &amp; ~C3 &amp; F8</td>
      <td class="nobr">1 AND3</td>
      <td>5</td>
   </tr>
   <tr class="listing">
      <td>S[6]</td>
      <td>S[7]</td>
      <td>S[7]</td>
      <td class="nobr">none</td>
      <td>0</td>
   </tr>
   <tr class="listing">
      <td>S[5]</td>
      <td>(S[6] &amp; C0) | (S[6] &amp; C1)</td>
      <td>~(~(S[6] &amp; C0) &amp; ~(S[6] &amp; C1))</td>
      <td class="nobr">
         3 NAND2
      </td>
      <td>9</td>
   </tr>
   <tr class="listing">
      <td>S[4]</td>
      <td>S[5]</td>
      <td>S[5]</td>
      <td class="nobr">none</td>
      <td>0</td>
   </tr>
   <tr class="listing">
      <td>S[3]</td>
      <td>S[4]</td>
      <td>S[4]</td>
      <td class="nobr">none</td>
      <td>0</td>
   </tr>
   <tr class="listing">
      <td>S[2]</td>
      <td>S[3]</td>
      <td>S[3]</td>
      <td class="nobr">none</td>
      <td>0</td>
   </tr>
   <tr class="listing">
      <td>S[1]</td>
      <td>S[2] | (S[6] &amp; C2) | (S[6] &amp; C3)</td>
      <td>~(~S[2] &amp; ~(S[6] &amp; C2) &amp; ~(S[6] &amp; C3))</td>
      <td class="nobr">
         1 NAND3<br/>
         2 NAND2
      </td>
      <td>12</td>
   </tr>
   <tr class="listing">
      <td>S[0]</td>
      <td>S[1] &amp; (C3 &amp; F8)</td>
      <td>S[1] &amp; C3 &amp; F8</td>
      <td class="nobr">1 AND3</td>
      <td>5</td>
   </tr>
</table>
<p/>

<h2 id="class">Class Decoder</h2>
<p>
The class decoder determines the type of instruction stored in the
I (instruction) register. The I register provides constant inverted
and non-inverted outputs to make decoding easier.<br/>
24 transistors are needed here.
</p>
<table class="listing">
   <tr class="head">
      <th>Opcode</th>
      <th>Class</th>
      <th>Description</th>
      <th>Size</th>
      <th>Logic</th>
      <th>Transistor Count</th>
   </tr>
   <tr class="listing">
      <td>0000 xxxx</td>
      <td>C0</td>
      <td>Jump</td>
      <td>3 bytes</td>
      <td>~I[7] &amp; ~I[6] &amp; ~I[5] &amp; ~I[4]</td>
      <td>6</td>
   </tr>
   <tr class="listing">
      <td>0001 xxxx</td>
      <td>C1</td>
      <td>Load/Store</td>
      <td>3 bytes</td>
      <td>~I[7] &amp; ~I[6] &amp; ~I[5] &amp; I[4]</td>
      <td>6</td>
   </tr>
   <tr class="listing">
      <td>0010 xxxx</td>
      <td>C2</td>
      <td>Math</td>
      <td>1 byte</td>
      <td>~I[7] &amp; ~I[6] &amp; I[5] &amp; ~I[4]</td>
      <td>6</td>
   </tr>
   <tr class="listing">
      <td>0011 xxxx</td>
      <td>C3</td>
      <td>Misc</td>
      <td>1 byte</td>
      <td>~I[7] &amp; ~I[6] &amp; I[5] &amp; I[4]</td>
      <td>6</td>
   </tr>
</table>
<p/>

<h2 id="func">Function Decoder</h2>
<p>
The function decoder determines the ALU operation to perform for C2
instructions and the control lines to drive for C1 and C3 instructions.<br/>
Note that the logic for branching is handled separately for C0
instructions.<br/>Both inverting and non-inverting outputs are provided
to make the control line decoder simpler.<br/>
63 transistors needed.
</p>
<table class="listing">
   <tr class="head">
      <th>Opcode</th>
      <th>Function</th>
      <th>Logic</th>
      <th>Transistor Count</th>
   </tr>
   <tr class="listing">
      <td>xxxx 0000</td>
      <td>F0</td>
      <td>~I[3] &amp; ~I[2] &amp; ~I[1] &amp; ~I[0]</td>
      <td>7</td>
   </tr>
   <tr class="listing">
      <td>xxxx 0001</td>
      <td>F1</td>
      <td>~I[3] &amp; ~I[2] &amp; ~I[1] &amp; I[0]</td>
      <td>7</td>
   </tr>
   <tr class="listing">
      <td>xxxx 0010</td>
      <td>F2</td>
      <td>~I[3] &amp; ~I[2] &amp; I[1] &amp; ~I[0]</td>
      <td>7</td>
   </tr>
   <tr class="listing">
      <td>xxxx 0011</td>
      <td>F3</td>
      <td>~I[3] &amp; ~I[2] &amp; I[1] &amp; I[0]</td>
      <td>7</td>
   </tr>
   <tr class="listing">
      <td>xxxx 0100</td>
      <td>F4</td>
      <td>~I[3] &amp; I[2] &amp; ~I[1] &amp; ~I[0]</td>
      <td>7</td>
   </tr>
   <tr class="listing">
      <td>xxxx 0101</td>
      <td>F5</td>
      <td>~I[3] &amp; I[2] &amp; ~I[1] &amp; I[0]</td>
      <td>7</td>
   </tr>
   <tr class="listing">
      <td>xxxx 0110</td>
      <td>F6</td>
      <td>~I[3] &amp; I[2] &amp; I[1] &amp; ~I[0]</td>
      <td>7</td>
   </tr>
   <tr class="listing">
      <td>xxxx 0111</td>
      <td>F7</td>
      <td>~I[3] &amp; I[2] &amp; I[1] &amp; I[0]</td>
      <td>7</td>
   </tr>
   <tr class="listing">
      <td>xxxx 1000</td>
      <td>F8</td>
      <td>I[3] &amp; ~I[2] &amp; ~I[1] &amp; ~I[0]</td>
      <td>7</td>
   </tr>
</table>
<p/>

<h2 id="control">Control Lines</h2>
<p>
This drives the 22 control lines for the computer. Due to the
number of transistors needed, it is split across two modules.<br/>
The first module controls lines 0 through 12 inclusive. The second
module drives lines 13 through 21 inclusive (including the TB line).<br/>
119 transistors needed for the first module.<br/>
116 transistors needed for the second module.
</p>
<table class="listing">
   <tr class="head">
      <th>No</th>
      <th>Name</th>
      <th>Logic</th>
      <th>Transistors</th>
   </tr>
   <tr class="listing">
      <td>0</td>
      <td>rd_A_d</td>
      <td class="nobr">
         ~(~(EX &amp; C1 &amp; F8)<br/>
         $ ~(EX &amp; C3 &amp; F0)<br/>
         $ ~(EX &amp; C3 &amp; F1)<br/>
         $ ~(EX &amp; C3 &amp; F2))
      </td>
      <td>17</td>
   </tr>
   <tr class="listing">
      <td>1</td>
      <td>wr_A_alu</td>
      <td class="nobr">
         EX &amp; C2 &amp; WC
      </td>
      <td>5</td>
   </tr>
   <tr class="listing">
      <td>2</td>
      <td>rd_B_d</td>
      <td class="nobr">
         ~(~(EX &amp; C1 &amp; F4)<br/>
         $ ~(EX &amp; C3 &amp; F3))
      </td>
      <td>9</td>
   </tr>
   <tr class="listing">
      <td>3</td>
      <td>wr_B_d</td>
      <td class="nobr">
         ~(~(EX &amp; C1 &amp; F0 &amp; WC)<br/>
         $ ~(EX &amp; C3 &amp; F0 &amp; WC)<br/>
         $ ~(EX &amp; C3 &amp; F5 &amp; WC))
      </td>
      <td>16</td>
   </tr>
   <tr class="listing">
      <td>4</td>
      <td>rd_C_d</td>
      <td class="nobr">
         ~(~(EX &amp; C1 &amp; F5)<br/>
         $ ~(EX &amp; C3 &amp; F4))
      </td>
      <td>9</td>
   </tr>
   <tr class="listing">
      <td>5</td>
      <td>wr_C_d</td>
      <td class="nobr">
         ~(~(EX &amp; C1 &amp; F1 &amp; WC)<br/>
         $ ~(EX &amp; C3 &amp; F1 &amp; WC)<br/>
         $ ~(EX &amp; C3 &amp; F6 &amp; WC))
      </td>
      <td>16</td>
   </tr>
   <tr class="listing">
      <td>6</td>
      <td>rd_XH_d</td>
      <td class="nobr">
         EX &amp; C1 &amp; F6
      </td>
      <td>5</td>
   </tr>
   <tr class="listing">
      <td>7</td>
      <td>wr_XH_d</td>
      <td class="nobr">
         EX &amp; C1 &amp; F2 &amp; WC
      </td>
      <td>6</td>
   </tr>
   <tr class="listing">
      <td>8</td>
      <td>rd_XL_d</td>
      <td class="nobr">
         EX &amp; C1 &amp; F7
      </td>
      <td>5</td>
   </tr>
   <tr class="listing">
      <td>9</td>
      <td>wr_XL_d</td>
      <td class="nobr">
         EX &amp; C1 &amp; F3 &amp; WC
      </td>
      <td>6</td>
   </tr>
   <tr class="listing">
      <td>10</td>
      <td>rd_X_a</td>
      <td class="nobr">
         (EX &amp; C3)<br/>
         $ ~(~F2 &amp; ~F3 &amp; ~F4 &amp; ~F5 &amp; ~F6 &amp; ~F7)
      </td>
      <td>11</td>
   </tr>
   <tr class="listing">
      <td>11</td>
      <td>wr_X_a</td>
      <td class="nobr">
         sP3 &amp; C0 &amp; TB &amp; I[3] &amp; WC
      </td>
      <td>7</td>
   </tr>
   <tr class="listing">
      <td>12</td>
      <td>rd_P_a</td>
      <td class="nobr">
         ~(~sF1 $ ~sF2 $ ~sF3)
      </td>
      <td>7</td>
   </tr>
   <tr class="listing">
      <td>13</td>
      <td>wr_P_a</td>
      <td class="nobr">
         ~(~(sP1 &amp; WC)<br/>
         $ ~(sP2 &amp; WC)<br/>
         $ ~(sP3 &amp; WC)<br/>
         $ ~(EX &amp; C0 &amp; TB &amp; WC)<br/>
         $ ~(EX &amp; C3 &amp; F7 &amp; WC))
      </td>
      <td>20</td>
   </tr>
   <tr class="listing">
      <td>14</td>
      <td>rd_N_a</td>
      <td class="nobr">
         ~(~sP1 $ ~sP2 $ ~sP3)
      </td>
      <td>7</td>
   </tr>
   <tr class="listing">
      <td>15</td>
      <td>wr_N</td>
      <td class="nobr">
         ~(~(sF1 &amp; WC)<br/>
         $ ~(sF2 &amp; WC)<br/>
         $ ~(sF3 &amp; WC))
      </td>
      <td>10</td>
   </tr>
   <tr class="listing">
      <td>16</td>
      <td>wr_I_d</td>
      <td class="nobr">
         sF1 &amp; WC
      </td>
      <td>4</td>
   </tr>
   <tr class="listing">
      <td>17</td>
      <td>rd_O_a</td>
      <td class="nobr">
         ~(~(EX &amp; C0)<br/>
         $ ~(EX &amp; C1))
      </td>
      <td>7</td>
   </tr>
   <tr class="listing">
      <td>18</td>
      <td>wr_OH_d</td>
      <td class="nobr">
         sF2 &amp; WC
      </td>
      <td>4</td>
   </tr>
   <tr class="listing">
      <td>19</td>
      <td>wr_OL_d</td>
      <td class="nobr">
         sF3 &amp; WC 
      </td>
      <td>4</td>
   </tr>
   <tr class="listing">
      <td>20</td>
      <td>mem_rd</td>
      <td class="nobr">
         ~(~sF1 $ ~sF2 $ ~sF3<br/>
            $ ~(EX &amp; C1 &amp; (~I[4] $ ~I[5]))<br/>
            $ ~(EX &amp; C3 &amp; F5)<br/>
            $ ~(EX &amp; C3 &amp; F6))
      </td>
      <td>21</td>
   </tr>
   <tr class="listing">
      <td>21</td>
      <td>mem_wr</td>
      <td class="nobr">
         ~(~((EX &amp; C1 &amp; WC)<br/>
         &nbsp;$ ~(~F4 &amp; ~F5 &amp; ~F6 &amp; ~F7 &amp; ~F8))<br/>
         $ ~((EX &amp; C3 &amp; WC)<br/>
         &nbsp;$ ~(~F2 &amp; ~F3 &amp; ~F4)))
      </td>
      <td>23</td>
   </tr>
   <tr class="listing">
      <td>-</td>
      <td>TB</td>
      <td class="nobr">
           ~(I[7] &amp; ~CF)<br/>
         $ ~(I[6] &amp; ~ZF)<br/>
         $ ~(I[5] &amp; ~NF)
      </td>
      <td>16</td>
   </tr>
</table>
<p/>

<div class="location">
   <a href="../../">Home</a> /
   <a href="../">Projects</a> /
   <a href=".">Q1</a>
</div>

      </div>
      <script>w3IncludeHTML();</script>
   </body>
</html>
