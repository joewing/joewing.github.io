---
layout: default
title: Q2 Implementation Details
---

<h1>{{ page.title }}</h1>

<h2>NMOS Logic</h2>

<p>
All logic in the Q2 is implemented using 2N7002 n-channel MOSFETs with
resistor pull-ups. Compared to a bipolar logic family like TTL, NMOS is
nice because it requires fewer components: an NMOS inverter requires only
a single transistor and a single pull-up resistor. Unfortunately, the
resistor pull-up presents a trade-off between speed and power, where
a lower value resistor pull-up will make the gate faster at the expense
of more power draw when the output is low. The situation is made worse
by the fact that most modern discrete MOSFETs have a rather high
gate capacitance (likely because they are made for switching large loads
rather than implementing logic), making fast logic tricky to implement
without using excessive power.
</p>

<p>
Although NMOS has a nearly unlimited fanout due to the high impedance
between the input and output, the gate capacitance
means that as we increase the fanout, the propagation delay increases. For
the Q2, we try to use mostly 10k pull-up resistors as a compromise between
speed and power. If we assume a load of 50pF and a Vth of 2.5 (pessimistic
values for the gate capacitance and threshold voltage of a 2N7002), this
gives us a propagation delay of around 347ns and a current draw of 0.5mA
at 5V for a fanout of one. As the fanout increases to, for example, 24 to
clock the A register, the propagation delay increases to 8.32us just for
the last level of logic. If we wanted to clock the Q2 at 100kHz, this
would leave us only 1.68us of slack for all other logic.
To avoid such issues, we track the fanout and insert 1k resistors instead
of 10k resistors in strategic locations, which in this case brings the delay
down to 832ns with a draw of 5mA.
</p>

<h2>Run Latch</h2>

<p>
The run latch controls whether the Q2 clock is enabled. The run latch
consists of a pair of cross-coupled inverters (2 transistors). Pressing
the &quot;Halt&quot; button pulls the &quot;Run&quot; signal to ground
and pressing the &quot;Run&quot; button pulls the other side to ground
causing the RUN signal to go high.
The &quot;Halt&quot; button is connected to ground through a capacitor,
which has the effect of pressing &quot;Halt&quot; when power is applied
so the Q2 comes up halted.
</p>

<center>
<img src="run.png" width="419" height="257">
</center>

<h2>Clock Generation</h2>

<p>
The clock for the Q2 is generated using a simple relaxation oscillator
constructed from a Schmitt trigger. The Schmitt trigger itself is
implemented using 3 2N7002 transistors. The output of the clock is
fed through two inverters to reduce load on the oscillator and
preserve the phase, which should be high when not running. To halt
the clock, an additional transistor gates the Schmitt trigger.
</p>

<center>
<img src="clock.png" width="753" height="461">
</center>

<p>
Being implemented using only NMOS transistors, the Schmitt
trigger is identical to the pull-down half of the traditional
CMOS Schmitt trigger design with a pull up resistor (R128).
An additional resistor (R132) is used to control the hysteresis
window. Larger value resistors will reduce the size of the
hysteresis window and conserve power. A smaller window
allows the oscillator to run faster, though too small of
a window and it will become unstable and eventually stop working.
</p>

<p>
The clock is divided into two non-overlapping clock phases: a state
clock (SC) and a write strobe (WS). The phases are generated using
the CDIV flip-fop and two NOR gates.
The SC clock is used to advance the state machine and the WS clock
is used to clock the other flip-flops and write to memory.
Having two phases simplifies writes to memory and I/O. Further,
it allows the state machine to be implemented as a simple binary
ripple counter (otherwise the ripple would cause glitches).
</p>

<h2>State Machine</h2>

<p>
The state machine is advanced on the rising edge of the SC clock.
There are 16 states. To reduce transistor count, the state machine
is implemented as a 4-bit binary ripple counter. Since not all
instructions use all states, the state decoder masks the DEREF
and LOAD states if they are not used. The state machine rolls over
without entering the ALU state if the ALU is not used.
This means all instructions take either 8 or 32 cycles to complete
depending on whether or not they use the ALU.
</p>

<p>
The states are:
</p>

<ul>
  <li>FETCH - Fetch the next instruction.</li>
  <li>DEREF - Dereference the operand if the dereference bit is set.</li>
  <li>LOAD - Load the operand from memory if this is an ALU instruction.</li>
  <li>EXEC - Execute the instruction or prepare the ALU.</li>
  <li>ALU - 12 states to run the 12 bits of A and X through the ALU.</li>
</ul>

<h2>Control Signals</h2>

<p>
The control signals are driven from the operand register and decoded
state. The simple instruction encoding makes the logic required to
drive the control signals fairly small.
</p>

<h2>Arithmetic Logic Unit</h2>

<p>
The ALU is bit-serial to reduce transistor count. During the 12 ALU
states, the bits from A and X are shifted through the ALU least-significant
first, and back to A. Depending on the opcode, the flag register tracks the
carry or zero status.
The ALU supports the following operations:
</p>

<table class="listing">
  <thead>
    <tr><th>Opcode</th><th>Name</th><th>Next A</th><th>Next F</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>x00</td><td>LDA</td>
      <td>X0</td><td>X0 &amp; ~F</td>
    </tr>
    <tr>
      <td>x01</td><td>NOR</td>
      <td>~(A0 | X0)</td><td>(A0 | X0) &amp; ~F</td>
    </tr>
    <tr>
      <td>x10</td><td>ADD</td>
      <td>A0 + X0 + F</td><td>(A0 &amp; X0) | (A0 &amp; F) | (X0 &amp; F)</td>
    </tr>
    <tr>
      <td>x11</td><td>SHR</td>
      <td>X1</td><td>F</td>
    </tr>
  </tbody>
</table>

<h2>Program Counter (P)</h2>

<p>
The program counter is made up of 12 positive-edge triggered D-flip-flops
configured as a 12-bit binary ripple counter. Incrementing the program
counter is accomplished by clocking the least-significant bit. To load
the program counter, either for a jump or at reset, the flip-flops also
have set/reset inputs.
</p>

<p>
Incrementing the program counter is slow, but the new value is not
needed until a minimum of 7 clock cycles later, which is plenty of
time.
</p>

<h2>Accumulator (A)</h2>

<p>
The accumulator is made up of 12 positive-edge triggered D-flip-flops
configured as a shift register. Clocking the A register causes the
output of the ALU to be shifted into the most significant bit (bit 11)
and all lower bits to be shifted down one. The output of the
least-significant bit (bit 0) is used as input to the ALU.
</p>

<p>
The A register can be read onto the data bus to execute the store
instruction (STA).
</p>

<h2>Operand (X)</h2>

<p>
Like the accumulator, the operand register is made up of 12 positive-edge
triggered D-flip-flops configured as a shift register.
Rather than the output of the ALU, zeros are shifted into the X register.
To load the operand register, the high bits can be set to zero (zero-page
loads), P (relative loads), the data bus (DBUS, for dereferencing), or
shifted.
The low bits can only be set to the data bus or shifted.
</p>

<h2>Opcode (O)</h2>

<p>
The opcode register is a 4-bit positive-edge triggered D-flip-flop.
It is loaded with the top 4-bits of the data bus during the FETCH
state to save the operation to perform. Note that the program counter
is incremented during the FETCH state as well, so being edge-triggered
is important (rather than a latch).
</p>

<h2>Flag (F)</h2>

<p>
The flag register is a positive-edge triggered D-flip-flop that
is used to keep track of carries when doing addition during
the ALU state and as a condition register for the <i>jump
flag clear</i> (JFC) instruction.
</p>

<p>
Unlike many modern architectures with flag registers, the Q2
only has a single flag to represent multiple conditions
(depending on the instruction). Not only does this reduce the
number of flip-flops required, but it also saves space
in the instruction encoding since only a single conditional
jump is needed.
</p>

<h2>RAM</h2>

<p>
The RAM for the Q2 is the one notable piece that is not
implemented out of discrete transistors. The goal was to
have a RAM that could save programs when powered off and
be implemented without substantially increasing the size or
power consumption of the Q2.
A DRAM structure was considered
(with large enough capacitors, DRAM will persist for a
reasonable amount of time), but even that would require two
transistors per bit, not to mention the address decoding logic
and sense amplifiers.
An actual core memory would be the most appropriate, but
such things are hard to find, and the assembly of one does
not appeal to me.
So given that an off-the-shelf SRAM already provides
exactly what we need, the Q2 goes that route.
</p>

<p>
The RAM for the Q2 is provided by two 6264 SRAM chips. Each
of these has an 8-bit data bus and a 13-bit address bus.
Since we only need 12 bits for the data bus, two of the
data pins on each are pulled to GND via 100k resistors. This
provides a stable value for writes and low-current draw during
reads. The extra address bit is connected to a bank select switch,
allowing two complete system images to be stored on the Q2.
</p>

<p>
An SRAM battery backup is provided for the SRAM to preserve
any programs when the Q2 is not powered.
</p>

<h2>Power</h2>

<p>
Since USB adapters are prevalent and provide an easy
5v power source, the Q2 was designed to use USB for
power. In general, this limits the power consumption
to be 500mA.
It is relatively easy to verify that the Q2 will
not draw too much power.
</p>

<p>
Each LED is driven through a 4.7k resistor. We assume
a 2v voltage drop through each LED, giving us a power
draw of 0.64mA per LED.
Each gate uses a 10k, a 1k, or a 100k resistor pull-up
(depending on the fanout and required speed), so we
assume 0.5mA for each 10k resistor and 5mA for each
1k resistor, and 0.05mA for each 100k resistor.
This provides an absolute worst-case estimate since
we don't expect all gates and LEDs to be drawing
power at all times (gates only draw power when the
output is low). We assume the RAM chips and
LCD each use 20mA.
This gives us:
</p>

<ul>
  <li>71 LEDs = 45mA</li>
  <li>376 10k resistors = 188mA</li>
  <li>19 100k resistors = 1mA</li>
  <li>17 1k resistors = 85mA</li>
  <li>2 RAM chips and 1 LCD = 60mA</li>
</ul>

<p>
So we get a total worst-case draw of 379mA or 1.9 Watts.
</p>

<h2 id="bom">Bill of Materials</h2>

<center><table class="listing">
  <thead>
    <tr>
      <th>Part</th>
      <th>Quantity</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>10k resistor</td><td>376</td><td></td></tr>
    <tr><td>100k resistor</td><td>19</td><td></td></tr>
    <tr><td>4.7k resistor</td><td>71</td><td></td></tr>
    <tr><td>1k resistor</td><td>17</td><td></td></tr>
    <tr><td>Blue LED</td><td>47</td><td></td></tr>
    <tr><td>White LED</td><td>24</td><td></td></tr>
    <tr><td>1nF capacitor</td><td>1</td><td></td></tr>
    <tr><td>100nF capacitor</td><td>18</td><td></td></tr>
    <tr><td>1uF capacitor</td><td>9</td><td></td></tr>
    <tr><td>BAT43 diode</td><td>19</td><td></td></tr>
    <tr><td>2N7002 transistor</td><td>1094</td><td></td></tr>
    <tr><td>6264 RAM</td><td>2</td><td></td></tr>
    <tr><td>1602A LCD</td><td>1</td><td>Hand-solder</td></tr>
    <tr><td>10k 3386P potentiometer</td><td>1</td><td>Hand-solder</td></tr>
    <tr><td>100k 3296W potentiometer</td><td>2</td><td>Hand-solder</td></tr>
    <tr><td>SPDT switch</td><td>14</td><td>Hand-solder</td></tr>
    <tr><td>USB-B connector</td><td>1</td><td>Hand-solder</td></tr>
    <tr><td>2x20 pinheader</td><td>1</td><td>Hand-solder</td></tr>
    </tr>
  </tbody>
</table></center>

